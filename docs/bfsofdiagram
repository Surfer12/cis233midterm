Let's illustrate how Breadth-First Search (BFS) traverses a graph with the following example:

**Example Graph:**

Consider a graph with nodes numbered 0 through 8, as depicted in the image below.


![alt text](<Screenshot 2024-11-24 at 8.07.28â€¯PM.png>)

[Image 1 from Djikstra.pdf]

**BFS Traversal:**

1. **Start at Node 0:** Mark it as visited and enqueue it.
2. **Dequeue Node 0:** Explore its unvisited neighbors (Nodes 1, 4, and 6). Mark them as visited and enqueue them.
3. **Dequeue Node 1:** Explore its unvisited neighbors (Nodes 2 and 7). Mark them as visited and enqueue them.
4. **Dequeue Node 4:** Explore its unvisited neighbors (Node 3 and 8). Mark them as visited and enqueue them.
5. **Dequeue Node 6:** It has no unvisited neighbors.
6. **Dequeue Node 2:** It has no unvisited neighbors.
7. **Dequeue Node 7:** It has no unvisited neighbors.
8. **Dequeue Node 3:** Explore its unvisited neighbor (Node 5). Mark it as visited and enqueue it.
9. **Dequeue Node 8:** It has no unvisited neighbors.
10. **Dequeue Node 5:** It has no unvisited neighbors.

**Traversal Order:**

The order in which nodes are dequeued and explored represents the BFS traversal of the graph: 0 -> 1 -> 4 -> 6 -> 2 -> 7 -> 3 -> 8 -> 5

**Key Idea:**

BFS explores the graph layer by layer, visiting all immediate neighbors of a node before moving on to their neighbors. This systematic approach ensures that all reachable nodes are visited in order of their proximity to the starting node.


```java
import java.util.*;

public class BFS {

    // Method to perform Breadth-First Search on a graph
    public static List<Integer> bfs(Map<Integer, List<Integer>> graph, int startNode) {
        List<Integer> visitedNodes = new ArrayList<>(); // List to store the order of visited nodes
        Queue<Integer> queue = new LinkedList<>(); // Queue to keep track of nodes to visit
        Set<Integer> visited = new HashSet<>(); // Set to keep track of visited nodes

        queue.offer(startNode); // Add the starting node to the queue
        visited.add(startNode); // Mark the starting node as visited

        while (!queue.isEmpty()) {
            int currentNode = queue.poll(); // Dequeue a node from the front of the queue
            visitedNodes.add(currentNode); // Add the dequeued node to the visited list

            // Iterate over the neighbors of the current node
            for (int neighbor : graph.get(currentNode)) {
                if (!visited.contains(neighbor)) { // If a neighbor hasn't been visited
                    visited.add(neighbor); // Mark the neighbor as visited
                    queue.offer(neighbor); // Enqueue the neighbor to visit it later
                }
            }
        }

        return visitedNodes; // Return the list of visited nodes in BFS order
    }

    public static void main(String[] args) {
        // Sample graph represented as an adjacency list
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(1, 4, 6));
        graph.put(1, Arrays.asList(0, 2, 7));
        graph.put(2, Arrays.asList(1));
        graph.put(3, Arrays.asList(4, 5));
        graph.put(4, Arrays.asList(0, 3, 8));
        graph.put(5, Arrays.asList(3));
        graph.put(6, Arrays.asList(0, 7));
        graph.put(7, Arrays.asList(1, 6));
        graph.put(8, Arrays.asList(4));

        int startNode = 0; // Starting node for BFS traversal
        List<Integer> bfsTraversal = bfs(graph, startNode); // Perform BFS

        System.out.println("BFS Traversal: " + bfsTraversal); // Print the traversal order
    }
}
```

**Output:**

```
BFS Traversal: [0, 1, 4, 6, 2, 7, 3, 8, 5]
```

**Explanation:**
Explanation:

The bfs method takes the graph represented as an adjacency list (Map<Integer, List<Integer>>) and the startNode as input.
It uses a Queue to store the nodes to be visited and a Set to track the visited nodes.
The algorithm starts by enqueuing and marking the startNode as visited.
It then iteratively dequeues nodes from the queue, explores their unvisited neighbors, marks them as visited, and enqueues them.
The main method creates a sample graph and calls the bfs method to perform the traversal.


The BFS traversal order is [0, 1, 4, 6, 2, 7, 3, 8, 5], which corresponds to the order in which the nodes are dequeued and explored during the BFS traversal. The starting node is 0, and the traversal visits all nodes in the graph in this order.

## Practice Problems

1. Time/Space Complexity:
   - Analyze the complexity of recursive factorial function
   - Compare complexity of iterative vs recursive binary search
   - Determine complexity of tree traversal algorithms
  
2. BST Operations:
   - Convert [1,2,3,4,5] to balanced BST
   - Implement BST deletion
   - Find height of a binary tree

3. Graph Problems:
   - Find shortest path between two vertices
   - Detect cycle in undirected graph
   - Implement graph as adjacency matrix and list

## Study Tips

1. Active Recall:
   - Write algorithms without referring to notes
   - Draw tree structures and perform operations by hand
   - Explain concepts to others

2. Practice Strategies:
   - Implement each algorithm from scratch
   - Use visualization tools for trees and graphs
   - Create test cases to verify implementations

3. Understanding Checks:
   - Can you explain the time/space complexity of each algorithm?
   - Can you draw the step-by-step process of tree traversals?      